Overview
========
Struct is a library for Lua 5.1. It provides functions for manipulating binary
data, in particular for unpacking binary files or byte buffers into Lua values
and for packing Lua values back into files or buffers. Supported data types
include:
	- signed and unsigned integers of arbitrary byte width
	- booleans and bitmasks
	- plain and null-terminated strings
	- fixed and floating point reals (the latter requires C module support)
In addition, the library supports seeking, alignment, and byte order controls,
repetition, grouping of data into tables, and naming of values within tables.

API
===	
exports:
	struct.pack([fd], fmt, ...)
	struct.unpack(<fd or string>, fmt)
	struct.explode(int)
	struct.implode(table)

pack takes a format string and zero or more data objects and packs them
into a buffer. If the first argument is a file descriptor, it will pack data
directly into that rather than generating and returning a buffer.

unpack takes a format string and a buffer or file to unpack from, and returns
each unpacked value as a seperate return value.

explode converts a bitmask into a list of booleans, and implode does the
converse. In such lists, list[1] is the least significant bit, and list[n]
the most significant.
	
The Format String
=================
The format string contains any number of endianness controls, seek controls,
format specifiers, and grouping/naming sequences, seperated by whitespace,
commas, or semicolons (or any mix thereof, although you are encouraged to
choose one and stick to it for the sake of consistency). Each of these is
detailed below.

Any entry in the format string can be prefixed with a number, or suffixed with
a '*' followed by a number, to repeat it that many times. For simplicity this is
permitted even for characters such as the endianness controls for which
repetition is meaningless.

In the documentation below, the convention is that A represents an address and W
a width in bytes. At present only base-10 numerals are supported.


Grouping
--------
Sequences of format specifiers can be grouped in the format string. This will
cause unpack to return the group as a single table rather than as distinct
values, and will cause pack to expect a single table in its arguments from which
the values can be extracted. Grouping is accomplished by enclosing the group
in {}. For example, the following format string:
	{ u4 i4 } { s32 u4 }
Would return two tables, the first one containing two numbers and the second
containing a string and a number.
Groups can be nested.


Naming
------
Within a group, values can be assigned names. Named values will be assigned
to the corresponding fields in the returned table, rather than to sequential
indices. For example, one might do:
	{ id:u3 comment:s125 offset:u4 flags:m1 }

Named and anonymous values can be freely mixed; the named values will be
assigned to their given fields and the anonymous ones to sequential indices.

Values can be assigned names outside of a group, but this will cause the
corresponding values to be discarded. Use the 'x' format (skip/pad) instead.


Repetition
----------
A group can be repeated by prefixing or suffixing it with a count, optionally
separated with a '*'. The '*', if present, cannot be seperated from the count
with whitespace (or any other character). For example:
	4 { u4 }
	4* { u4 }
	{ u4 } 4
	{ u4 } *4
	{ u4 } { u4 } { u4 } { u4 }
Are all equivalent. Note that the whitespace in the above examples is optional.
In cases where you want to repeat format specifiers without implying a grouping,
you can use (). For example:
	4 (u4)
Is equivalent to:
	u4 u4 u4 u4
Like grouping, these can be nested.


Format Specifiers
=================

Endianness Controls
-------------------
The formats i, m, and u are affected by the endianness setting, which controls
the order in which bytes are read and written within a field. The following
characters in a format string adjust the endianness setting:

<
	Sets the endianness to little-endian (eg, Intel processors)
>
	Sets the endianness to big-endian (eg, PPC and Motorola processors)
=
	Sets the endianness to the native endianness.


Seek Controls
-------------
These characters are used to seek to specific locations in the input or output.
Note that they only work on buffers or file-like objects that support the seek()
method; for streams which cannot be sought on, use the 'x' (skip/null-pad)
data format instead.

@A
	Seek to absolute address A.
+A
	Seek forward A bytes.
-A
	Seek backwards A bytes.
aW
	Align to word width W (ie, seek to the next address which is a multiple of W)


Data Format Specifiers
----------------------
bW	Boolean.
	Read: as uW, but returns true if the result is non-zero and false otherwise.
	Write: as uW with input 1 if true and 0 otherwise.

fW
	IEEE floating point. NOT IMPLEMENTED.
	Valid widths are 4 (float) 8 (double) and 16 (quad)

iW	Signed integer.
	Read: a signed integer of width W bytes.
	Write: a signed integer of width W bytes.
	Floating point values will be truncated.
	Affected by endianness.

mW	Bitmask.
	Read: as uW, but explodes the result into a list of booleans, one per bit.
	Write: implodes the input value, then writes it as uW.
	Affected by endianness.
	See also: struct.implode, struct.explode.

pW	Fixed point rational.
	Width is in the format "I.F"; the value before the dot is the number of
	*BITS* in the integer part, and the value after, in the fractional part.
	Read: a fixed point rational of I+F bits.
	Write: a fixed point rational of I+F bits. Values which cannot be exactly
	represented in the specified width are truncated.
	Affected by endianness.
	Note that underlying reads must still occur in byte multiples. Using a W
	such that I+F is not a multiple of 8 is an error.

sW	String.
	Read: reads exactly W bytes and returns them as a string.
	Write:
	If W is 0, uses the string length.
	If W is shorter than the string length, truncates the string.
	If W is greater than the string length, null pads the string.

uW	Unsigned integer.
	Read: an unsigned integer of width W bytes.
	Write: an unsigned integer of width W bytes.
	Floating point values will be truncated.
	Negative values will be taken absolute.
	Affected by endianness.

xW	Skip/pad.
	Read: read and discard the next W bytes.
	Write: write W zero bytes.

zW	Null terminated string.
	Read: reads exactly W bytes. Returns everything up to the first zero byte.
	If W is 0, reads up to the next zero byte.
	Write: writes exactly W bytes.
	If the input is shorter than W, zero pads the output.
	If as long or longer, truncates to W-1 and writes a zero byte at the end.

